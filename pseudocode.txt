global var sources = [<loaded from file>];
global var sinks = [<loaded from file>];
global var tainted_var = []<TaintedVar>;
global var vulnerabilities = [];

// A stack to save the info about in which block it is,
// e.g.: in an If block inside a While block, etc...
global var stack = new Stack();

enum PresentIn {
    SOURCES,
    TAINED,
    SINKS,
    NONE
}

type TaintedVar {
    // list of sources it got tainted from
    from: [String],
    // name of the variable
    name: String,
}


func analyze(Dict: node) {
    switch node.type {
        case contains 'Program' {
            for (stm : node.body) {
                statement(stm);
            }
        }
        case contains 'Expression' | 'Literal' => {
            expression(node);
        }
        default {
            return;
        }
    }
}

func identifier(node) -> (type=PresentIn, name=name) {
    if (node.name in sources)
        return (PresentIn.SOURCES, node.name);

    if (node.name in tained_var)
        return (PresentIn.TAINED, node.name);

    if (node.name in sinks)
        return (PresentIn.SINKS, node.name);

    return (PresentIn.NONE, node.name);
}

// Anything that can be from a single line of code
// to a block of code
// E.g.: Statement 1:   let a = b;
//       Statement 2:   if (a == 0 ) {
//                          ...
//                      }
func statement(node) {
    switch node.type {
        case 'ExpressionStatement' {
            expression(node.expression);
        }
        case 'BlockStatement' {
            for (statementnode : node.body) {
                statement(statementnode);
            }
        }
        case 'IfStatement' {
            stack.push("If");
            expression(node.test);
            statement(node.consequent);
            if (node.alternate != null) {
                statement(node.alternate);
            }
        }
        case 'WhileStatement' || 'DoWhileStatement ' {
            stack.push("While");
            expression(node.test);
            statement(node.body);
            stack.pop();
        }
        default {
            return;
        }
    }
}

// Anything that declares something, from variables to
// functions
func declaration(node) {
    switch node.type {
        case 'FunctionDeclaration' {
            // TODO: idk
        }
        case 'VariableDeclaration' {
            for (declararator : node.declarations) {
                expression(declararator.init);
            }
        }
    }
}

// 
func expression(node) -> PresentIn {
    switch node.type {
        case 'ThisExpression' {
            return;
        }
        case 'ArrayExpression' {
            for (element : node.elements) {
                if (element == null)
                    continue;
                expression(element);
            }
        }
        case 'ObjectExpression' {
            // Not as part of the project
            return;
        }
        case 'FunctionExpression' {
            return;
        }
        case 'UnaryExpression' || 'UpdateExpression' {
            expression(node.argument);
        }
        case 'BinaryExpression ' {
            expression(node.left);
            expression(node.right);
        }
        case 'AssignmentExpression' {
            assignment_expr(node);
        }
        case 'LogicalExpression' {
            expression(node.left);
            expression(node.right);
        }
        case 'MemberExpression' {
            expression(node.object);
            expression(node.property);
        }
        case 'CallExpression' {
            expression(node.callee);
            for (arg : node.arguments) {
                expression(arg);
            }
        }
        default {
            return;
        }
    }
}

func assignment_expr(node) {
    // result of the left hand side 
    var result_left;

    // result of the right hand side 
    var result_right;

    if (node.left.type contains 'Expression') {
        result_left = expression(node.left);
    } else {
        result_left = identifier(node.left);
    }
    result_right = expression(node.right);

    if (result_right.type == PresentIn.SOURCES || 
        result_right.type == PresentIn.TAINTED) {
        
        // If the left hand side is a sink, then register the vulnerability
        if (result_left.type == PresentIn.SINK)
            // How to implement this part is still to be discussed
            vulnerabilities.add();

        // If the left hand side is a 'clean' variable, then it becomes tainted
        if (result_left.type == PresentIn.NONE)
            // How to implement this part is still to be discussed
            tainted_var.add(result_left.name);
        
        // If the left hand side is already tainted, then update it's sources
        if (result_left.type == PresentIn.TAINTED)
            var already_tainted = tainted_var.get(result_left.name);
            already_tainted.add_source(result_right);
            tainted_var.add(already_tainted);
    }
}
